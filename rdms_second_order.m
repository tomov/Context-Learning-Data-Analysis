function [table_Rho, table_H, table_T, table_P, all_subject_rhos, lmes] = rdms_second_order(metadata, rows, cols, control_col_idxs, do_LME, lme_row_idxs, lme_col_idxs)

% Perform second-order RDM analysis
%
% metadata = subject metadata as output by load_data
% rows = struct array of RDMs to compare against cols, as generated by e.g. rdms_get_neural() or rdms_get_model()
% cols = struct array of RDMs to compare against rows, as generated by e.g. rdms_get_neural() or rdms_get_model()
% control_col_idxs = indices of RDMs in cols (assumes Model RDMs) to control for
% do_LME = whether to do linear mixed effects modeling analysis
% lme_row_idxs = which row RDMs to include in LME analysis (assumes Neural RDMs)
% lme_col_idxs = which col RDMs to include in LME analysis (assumes Model RDMs)
%

disp('Computing second-order RDM...');
tic;

% Some knobs that don't really matter
%
same_run_only = false; % #KNOB compute correlation for each run separately i.e. no comparisons of representations across runs

if do_LME
    assert(~isequal(rows, cols)); % LME compares neural with model RDMs; can't do all vs. all
end

% upper right triangle, excluding diagonal, for all runs
%
cross_run_trig = logical(triu(ones(metadata.runsPerSubject * metadata.trainingTrialsPerRun), 1));
cross_run_trig_control = repmat(cross_run_trig, 1, 1, numel(control_col_idxs));

% upper right triangle, excluding diagonal, for a single run
%
same_run_trig = false(metadata.runsPerSubject * metadata.trainingTrialsPerRun);
for run = 1:metadata.runsPerSubject
    s = (run - 1) * metadata.trainingTrialsPerRun + 1;
    e = run * metadata.trainingTrialsPerRun;
    same_run_trig(s:e,s:e) = logical(triu(ones(metadata.trainingTrialsPerRun), 1));
end
same_run_trig_control = repmat(same_run_trig, 1, 1, numel(control_col_idxs));

% Initialize results
%
table_Rho = []; % average Spearman's rho for each ROI for each model
table_H = []; % result of hypothesis test for each ROI for each model -- is the correlation significant?
table_T = []; % t-value of hypothesis test for each ROI for each model
table_P = []; % p-value of hypothesis test for each ROI for each model
all_subject_rhos = nan(numel(rows), numel(cols), metadata.N);
lmes = {};

% Do the work
%
for row_idx = 1:numel(rows)
    fprintf('Row %d\n', row_idx);

    models_subjs_rhos = []; % Spearman rhos: row = model, col = subject
    for col_idx = 1:numel(cols)

        if do_LME && ismember(row_idx, lme_row_idxs) && ismember(col_idx, lme_col_idxs)
            lme_neural = [];
            lme_model = [];
            lme_ids = [];
            lme_controls = [];
        end

        % Compute a Spearman's rank correlation for each subject separately
        %
        subjs_rhos = []; % Spearman rhos: col = subject, one rho per
        for subj = 1:metadata.N
            % get the RDMs to correlate
            %
            row_RDM = rows(row_idx).RDMs(:,:,subj);
            col_RDM = cols(col_idx).RDMs(:,:,subj);
            control_RDMs = nan(size(row_RDM, 1), size(row_RDM, 2), numel(control_col_idxs));
            for i = 1:numel(control_col_idxs) 
                control_RDMs(:,:,i) = cols(control_col_idxs(i)).RDMs(:,:,subj);
            end
            assert(isequal(size(row_RDM), size(col_RDM)));
            assert(isequal(size(cross_run_trig), size(row_RDM)));
            assert(isequal(size(same_run_trig), size(row_RDM)));

            % get the appropriate entries from the RDMs
            %
            if same_run_only
                % Look at RDMs for each run separately => same-run
                % correlations only
                %
                x = row_RDM(same_run_trig);
                y = col_RDM(same_run_trig);
                z = control_RDMs(same_run_trig_control);
            else
                % Look at RDMs for all runs simultaneously => includes
                % cross-run correlations
                %
                x = row_RDM(cross_run_trig);
                y = col_RDM(cross_run_trig);
                z = control_RDMs(cross_run_trig_control);
            end
           
            % compute the correlations
            %
            if numel(control_col_idxs) > 0
                z = reshape(z, size(x, 1), numel(control_col_idxs));
                subj_rho = partialcorr(x, y, z, 'type', 'Spearman');
                subjs_rhos = [subjs_rhos, subj_rho];
            else
                subj_rho = corr(x, y, 'type', 'Spearman');
                subjs_rhos = [subjs_rhos, subj_rho];
            end
            all_subject_rhos(row_idx, col_idx, subj) = subj_rho;            

            % if we're doing LMEs
            %
            if do_LME && ismember(row_idx, lme_row_idxs) && ismember(col_idx, lme_col_idxs)
                lme_neural = [lme_neural; x];
                lme_model = [lme_model; y];
                lme_ids = [lme_ids; ones(size(x,1),1) * subj];
                lme_controls = [lme_controls; z];
            end
        end
        models_subjs_rhos = [models_subjs_rhos; subjs_rhos]; % for group-level analysis

        % if we're doing LMEs
        %
        if do_LME && ismember(row_idx, lme_row_idxs) && ismember(col_idx, lme_col_idxs)
            assert(isequal(control_col_idxs, [8 12])); % time & run
            tbl = array2table([lme_neural, lme_model, lme_ids, lme_controls], 'VariableNames', {'Neural', 'Model', 'Subject', 'Time', 'Run'});
            formula = 'Neural ~ Model + Run + Time + (Model|Subject) + (Run-1|Subject) + (Time|Subject)';
            fprintf('LME for %s vs. %s: %s\n', rows(row_idx).name, cols(col_idx).name, formula);
            lme = fitlme(tbl, formula);
            lmes{row_idx, col_idx} = lme;
        end
    end
    
    % Group-level analysis -- collapse across subjects
    % for each model, do a t-test of the correlation coefficients between
    % each subject's neural RDM and the corresponding model RDM
    %
    fisher_models_rhos = atanh(models_subjs_rhos);
    [h, ps, ci, stats] = ttest(fisher_models_rhos');

    table_Rho = [table_Rho; mean(fisher_models_rhos')];
    table_H = [table_H; h];
    table_P = [table_P; ps];
    table_T = [table_T; stats.tstat];
end



disp('Computed second-order RDM.');
toc;
